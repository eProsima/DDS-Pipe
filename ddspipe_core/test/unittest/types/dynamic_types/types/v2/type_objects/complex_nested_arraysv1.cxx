// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file complex_nested_arrays.cpp
 * This source file contains the implementation of the described types in the IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "complex_nested_arrays.h"

#if FASTCDR_VERSION_MAJOR == 1

#include "complex_nested_arraysTypeObject.h"

#include <fastcdr/Cdr.h>


#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

namespace helper { namespace internal {

enum class Size {
    UInt8,
    UInt16,
    UInt32,
    UInt64,
};

constexpr Size get_size(int s) {
    return (s <= 8 ) ? Size::UInt8:
           (s <= 16) ? Size::UInt16:
           (s <= 32) ? Size::UInt32: Size::UInt64;
}

template<Size s>
struct FindTypeH;

template<>
struct FindTypeH<Size::UInt8> {
    using type = std::uint8_t;
};

template<>
struct FindTypeH<Size::UInt16> {
    using type = std::uint16_t;
};

template<>
struct FindTypeH<Size::UInt32> {
    using type = std::uint32_t;
};

template<>
struct FindTypeH<Size::UInt64> {
    using type = std::uint64_t;
};
}

template<int S>
struct FindType {
    using type = typename internal::FindTypeH<internal::get_size(S)>::type;
};
}

#define FirstLevelElement_max_cdr_typesize 296ULL;
#define ThirdLevelElement_max_cdr_typesize 24ULL;
#define SecondLevelElement_max_cdr_typesize 56ULL;
#define complex_nested_arrays_max_cdr_typesize 896ULL;




ThirdLevelElement::ThirdLevelElement()
{
    // double m_x
    m_x = 0.0;
    // double m_y
    m_y = 0.0;

    // Just to register all known types
    registercomplex_nested_arraysTypes();
}

ThirdLevelElement::~ThirdLevelElement()
{
}

ThirdLevelElement::ThirdLevelElement(
        const ThirdLevelElement& x)
{
    m_x = x.m_x;


    m_y = x.m_y;

}

ThirdLevelElement::ThirdLevelElement(
        ThirdLevelElement&& x) noexcept
{
    m_x = x.m_x;


    m_y = x.m_y;

}

ThirdLevelElement& ThirdLevelElement::operator =(
        const ThirdLevelElement& x)
{
    m_x = x.m_x;


    m_y = x.m_y;

    return *this;
}

ThirdLevelElement& ThirdLevelElement::operator =(
        ThirdLevelElement&& x) noexcept
{
    m_x = x.m_x;


    m_y = x.m_y;

    return *this;
}

bool ThirdLevelElement::operator ==(
        const ThirdLevelElement& x) const
{
    return (m_x == x.m_x &&
           m_y == x.m_y);
}

bool ThirdLevelElement::operator !=(
        const ThirdLevelElement& x) const
{
    return !(*this == x);
}

size_t ThirdLevelElement::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return ThirdLevelElement_max_cdr_typesize;
}

size_t ThirdLevelElement::getCdrSerializedSize(
        const ThirdLevelElement& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}


void ThirdLevelElement::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_x;

    scdr << m_y;

}

void ThirdLevelElement::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_x;



    dcdr >> m_y;


}


bool ThirdLevelElement::isKeyDefined()
{
    return false;
}

void ThirdLevelElement::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void ThirdLevelElement::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double ThirdLevelElement::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& ThirdLevelElement::x()
{
    return m_x;
}


/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void ThirdLevelElement::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double ThirdLevelElement::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& ThirdLevelElement::y()
{
    return m_y;
}







SecondLevelElement::SecondLevelElement()
{
    // ThirdLevelElement m_an_element_alone

    // sequence<ThirdLevelElement, 1> m_a_limited_other_value


    // Just to register all known types
    registercomplex_nested_arraysTypes();
}

SecondLevelElement::~SecondLevelElement()
{
}

SecondLevelElement::SecondLevelElement(
        const SecondLevelElement& x)
{
    m_an_element_alone = x.m_an_element_alone;


    m_a_limited_other_value = x.m_a_limited_other_value;

}

SecondLevelElement::SecondLevelElement(
        SecondLevelElement&& x) noexcept
{
    m_an_element_alone = std::move(x.m_an_element_alone);


    m_a_limited_other_value = std::move(x.m_a_limited_other_value);

}

SecondLevelElement& SecondLevelElement::operator =(
        const SecondLevelElement& x)
{
    m_an_element_alone = x.m_an_element_alone;


    m_a_limited_other_value = x.m_a_limited_other_value;

    return *this;
}

SecondLevelElement& SecondLevelElement::operator =(
        SecondLevelElement&& x) noexcept
{
    m_an_element_alone = std::move(x.m_an_element_alone);


    m_a_limited_other_value = std::move(x.m_a_limited_other_value);

    return *this;
}

bool SecondLevelElement::operator ==(
        const SecondLevelElement& x) const
{
    return (m_an_element_alone == x.m_an_element_alone &&
           m_a_limited_other_value == x.m_a_limited_other_value);
}

bool SecondLevelElement::operator !=(
        const SecondLevelElement& x) const
{
    return !(*this == x);
}

size_t SecondLevelElement::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return SecondLevelElement_max_cdr_typesize;
}

size_t SecondLevelElement::getCdrSerializedSize(
        const SecondLevelElement& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ThirdLevelElement::getCdrSerializedSize(data.an_element_alone(), current_alignment);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.a_limited_other_value().size(); ++a)
    {
        current_alignment += ThirdLevelElement::getCdrSerializedSize(data.a_limited_other_value().at(a), current_alignment);
    }



    return current_alignment - initial_alignment;
}


void SecondLevelElement::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_an_element_alone;

    scdr << m_a_limited_other_value;


}

void SecondLevelElement::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_an_element_alone;



    dcdr >> m_a_limited_other_value;


}


bool SecondLevelElement::isKeyDefined()
{
    return false;
}

void SecondLevelElement::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

/*!
 * @brief This function copies the value in member an_element_alone
 * @param _an_element_alone New value to be copied in member an_element_alone
 */
void SecondLevelElement::an_element_alone(
        const ThirdLevelElement& _an_element_alone)
{
    m_an_element_alone = _an_element_alone;
}

/*!
 * @brief This function moves the value in member an_element_alone
 * @param _an_element_alone New value to be moved in member an_element_alone
 */
void SecondLevelElement::an_element_alone(
        ThirdLevelElement&& _an_element_alone)
{
    m_an_element_alone = std::move(_an_element_alone);
}

/*!
 * @brief This function returns a constant reference to member an_element_alone
 * @return Constant reference to member an_element_alone
 */
const ThirdLevelElement& SecondLevelElement::an_element_alone() const
{
    return m_an_element_alone;
}

/*!
 * @brief This function returns a reference to member an_element_alone
 * @return Reference to member an_element_alone
 */
ThirdLevelElement& SecondLevelElement::an_element_alone()
{
    return m_an_element_alone;
}


/*!
 * @brief This function copies the value in member a_limited_other_value
 * @param _a_limited_other_value New value to be copied in member a_limited_other_value
 */
void SecondLevelElement::a_limited_other_value(
        const std::vector<ThirdLevelElement>& _a_limited_other_value)
{
    m_a_limited_other_value = _a_limited_other_value;
}

/*!
 * @brief This function moves the value in member a_limited_other_value
 * @param _a_limited_other_value New value to be moved in member a_limited_other_value
 */
void SecondLevelElement::a_limited_other_value(
        std::vector<ThirdLevelElement>&& _a_limited_other_value)
{
    m_a_limited_other_value = std::move(_a_limited_other_value);
}

/*!
 * @brief This function returns a constant reference to member a_limited_other_value
 * @return Constant reference to member a_limited_other_value
 */
const std::vector<ThirdLevelElement>& SecondLevelElement::a_limited_other_value() const
{
    return m_a_limited_other_value;
}

/*!
 * @brief This function returns a reference to member a_limited_other_value
 * @return Reference to member a_limited_other_value
 */
std::vector<ThirdLevelElement>& SecondLevelElement::a_limited_other_value()
{
    return m_a_limited_other_value;
}





FirstLevelElement::FirstLevelElement()
{
    // /type_d() m_useless_name

    // sequence<SecondLevelElement> m_sub

    // ThirdLevelElement m_an_element_alone


    // Just to register all known types
    registercomplex_nested_arraysTypes();
}

FirstLevelElement::~FirstLevelElement()
{
}

FirstLevelElement::FirstLevelElement(
        const FirstLevelElement& x)
{
    m_useless_name = x.m_useless_name;


    m_sub = x.m_sub;


    m_an_element_alone = x.m_an_element_alone;

}

FirstLevelElement::FirstLevelElement(
        FirstLevelElement&& x) noexcept
{
    m_useless_name = std::move(x.m_useless_name);


    m_sub = std::move(x.m_sub);


    m_an_element_alone = std::move(x.m_an_element_alone);

}

FirstLevelElement& FirstLevelElement::operator =(
        const FirstLevelElement& x)
{
    m_useless_name = x.m_useless_name;


    m_sub = x.m_sub;


    m_an_element_alone = x.m_an_element_alone;

    return *this;
}

FirstLevelElement& FirstLevelElement::operator =(
        FirstLevelElement&& x) noexcept
{
    m_useless_name = std::move(x.m_useless_name);


    m_sub = std::move(x.m_sub);


    m_an_element_alone = std::move(x.m_an_element_alone);

    return *this;
}

bool FirstLevelElement::operator ==(
        const FirstLevelElement& x) const
{
    return (m_useless_name == x.m_useless_name &&
           m_sub == x.m_sub &&
           m_an_element_alone == x.m_an_element_alone);
}

bool FirstLevelElement::operator !=(
        const FirstLevelElement& x) const
{
    return !(*this == x);
}

size_t FirstLevelElement::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return FirstLevelElement_max_cdr_typesize;
}

size_t FirstLevelElement::getCdrSerializedSize(
        const FirstLevelElement& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.useless_name().size() + 1;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.sub().size(); ++a)
    {
        current_alignment += SecondLevelElement::getCdrSerializedSize(data.sub().at(a), current_alignment);
    }



    current_alignment += ThirdLevelElement::getCdrSerializedSize(data.an_element_alone(), current_alignment);


    return current_alignment - initial_alignment;
}


void FirstLevelElement::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_useless_name.c_str();

    scdr << m_sub;


    scdr << m_an_element_alone;

}

void FirstLevelElement::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_useless_name;



    dcdr >> m_sub;



    dcdr >> m_an_element_alone;


}


bool FirstLevelElement::isKeyDefined()
{
    return false;
}

void FirstLevelElement::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

/*!
 * @brief This function copies the value in member useless_name
 * @param _useless_name New value to be copied in member useless_name
 */
void FirstLevelElement::useless_name(
        const std::string& _useless_name)
{
    m_useless_name = _useless_name;
}

/*!
 * @brief This function moves the value in member useless_name
 * @param _useless_name New value to be moved in member useless_name
 */
void FirstLevelElement::useless_name(
        std::string&& _useless_name)
{
    m_useless_name = std::move(_useless_name);
}

/*!
 * @brief This function returns a constant reference to member useless_name
 * @return Constant reference to member useless_name
 */
const std::string& FirstLevelElement::useless_name() const
{
    return m_useless_name;
}

/*!
 * @brief This function returns a reference to member useless_name
 * @return Reference to member useless_name
 */
std::string& FirstLevelElement::useless_name()
{
    return m_useless_name;
}


/*!
 * @brief This function copies the value in member sub
 * @param _sub New value to be copied in member sub
 */
void FirstLevelElement::sub(
        const std::vector<SecondLevelElement>& _sub)
{
    m_sub = _sub;
}

/*!
 * @brief This function moves the value in member sub
 * @param _sub New value to be moved in member sub
 */
void FirstLevelElement::sub(
        std::vector<SecondLevelElement>&& _sub)
{
    m_sub = std::move(_sub);
}

/*!
 * @brief This function returns a constant reference to member sub
 * @return Constant reference to member sub
 */
const std::vector<SecondLevelElement>& FirstLevelElement::sub() const
{
    return m_sub;
}

/*!
 * @brief This function returns a reference to member sub
 * @return Reference to member sub
 */
std::vector<SecondLevelElement>& FirstLevelElement::sub()
{
    return m_sub;
}


/*!
 * @brief This function copies the value in member an_element_alone
 * @param _an_element_alone New value to be copied in member an_element_alone
 */
void FirstLevelElement::an_element_alone(
        const ThirdLevelElement& _an_element_alone)
{
    m_an_element_alone = _an_element_alone;
}

/*!
 * @brief This function moves the value in member an_element_alone
 * @param _an_element_alone New value to be moved in member an_element_alone
 */
void FirstLevelElement::an_element_alone(
        ThirdLevelElement&& _an_element_alone)
{
    m_an_element_alone = std::move(_an_element_alone);
}

/*!
 * @brief This function returns a constant reference to member an_element_alone
 * @return Constant reference to member an_element_alone
 */
const ThirdLevelElement& FirstLevelElement::an_element_alone() const
{
    return m_an_element_alone;
}

/*!
 * @brief This function returns a reference to member an_element_alone
 * @return Reference to member an_element_alone
 */
ThirdLevelElement& FirstLevelElement::an_element_alone()
{
    return m_an_element_alone;
}





complex_nested_arrays::complex_nested_arrays()
{
    // FirstLevelElement m_array_of_elements


    // Just to register all known types
    registercomplex_nested_arraysTypes();
}

complex_nested_arrays::~complex_nested_arrays()
{
}

complex_nested_arrays::complex_nested_arrays(
        const complex_nested_arrays& x)
{
    m_array_of_elements = x.m_array_of_elements;

}

complex_nested_arrays::complex_nested_arrays(
        complex_nested_arrays&& x) noexcept
{
    m_array_of_elements = std::move(x.m_array_of_elements);

}

complex_nested_arrays& complex_nested_arrays::operator =(
        const complex_nested_arrays& x)
{
    m_array_of_elements = x.m_array_of_elements;

    return *this;
}

complex_nested_arrays& complex_nested_arrays::operator =(
        complex_nested_arrays&& x) noexcept
{
    m_array_of_elements = std::move(x.m_array_of_elements);

    return *this;
}

bool complex_nested_arrays::operator ==(
        const complex_nested_arrays& x) const
{
    return (m_array_of_elements == x.m_array_of_elements);
}

bool complex_nested_arrays::operator !=(
        const complex_nested_arrays& x) const
{
    return !(*this == x);
}

size_t complex_nested_arrays::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return complex_nested_arrays_max_cdr_typesize;
}

size_t complex_nested_arrays::getCdrSerializedSize(
        const complex_nested_arrays& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    for(size_t a = 0; a < data.array_of_elements().size(); ++a)
    {
            current_alignment += FirstLevelElement::getCdrSerializedSize(data.array_of_elements().at(a), current_alignment);

    }



    return current_alignment - initial_alignment;
}


void complex_nested_arrays::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_array_of_elements;


}

void complex_nested_arrays::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_array_of_elements;


}


bool complex_nested_arrays::isKeyDefined()
{
    return false;
}

void complex_nested_arrays::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}

/*!
 * @brief This function copies the value in member array_of_elements
 * @param _array_of_elements New value to be copied in member array_of_elements
 */
void complex_nested_arrays::array_of_elements(
        const std::array<FirstLevelElement, 3>& _array_of_elements)
{
    m_array_of_elements = _array_of_elements;
}

/*!
 * @brief This function moves the value in member array_of_elements
 * @param _array_of_elements New value to be moved in member array_of_elements
 */
void complex_nested_arrays::array_of_elements(
        std::array<FirstLevelElement, 3>&& _array_of_elements)
{
    m_array_of_elements = std::move(_array_of_elements);
}

/*!
 * @brief This function returns a constant reference to member array_of_elements
 * @return Constant reference to member array_of_elements
 */
const std::array<FirstLevelElement, 3>& complex_nested_arrays::array_of_elements() const
{
    return m_array_of_elements;
}

/*!
 * @brief This function returns a reference to member array_of_elements
 * @return Reference to member array_of_elements
 */
std::array<FirstLevelElement, 3>& complex_nested_arrays::array_of_elements()
{
    return m_array_of_elements;
}




#endif // FASTCDR_VERSION_MAJOR == 1
