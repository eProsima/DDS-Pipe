// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file complex_nested_arrays.cpp
 * This source file contains the implementation of the described types in the IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "complex_nested_arrays.h"

#if FASTCDR_VERSION_MAJOR > 1

#include "complex_nested_arraysTypeObject.h"

#include <fastcdr/Cdr.h>


#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>




ThirdLevelElement::ThirdLevelElement()
{
    // Just to register all known types
    registercomplex_nested_arraysTypes();
}

ThirdLevelElement::~ThirdLevelElement()
{
}

ThirdLevelElement::ThirdLevelElement(
        const ThirdLevelElement& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
}

ThirdLevelElement::ThirdLevelElement(
        ThirdLevelElement&& x) noexcept
{
    m_x = x.m_x;
    m_y = x.m_y;
}

ThirdLevelElement& ThirdLevelElement::operator =(
        const ThirdLevelElement& x)
{

    m_x = x.m_x;
    m_y = x.m_y;
    return *this;
}

ThirdLevelElement& ThirdLevelElement::operator =(
        ThirdLevelElement&& x) noexcept
{

    m_x = x.m_x;
    m_y = x.m_y;
    return *this;
}

bool ThirdLevelElement::operator ==(
        const ThirdLevelElement& x) const
{
    return (m_x == x.m_x &&
           m_y == x.m_y);
}

bool ThirdLevelElement::operator !=(
        const ThirdLevelElement& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void ThirdLevelElement::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double ThirdLevelElement::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& ThirdLevelElement::x()
{
    return m_x;
}


/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void ThirdLevelElement::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double ThirdLevelElement::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& ThirdLevelElement::y()
{
    return m_y;
}






SecondLevelElement::SecondLevelElement()
{
    // Just to register all known types
    registercomplex_nested_arraysTypes();
}

SecondLevelElement::~SecondLevelElement()
{
}

SecondLevelElement::SecondLevelElement(
        const SecondLevelElement& x)
{
    m_an_element_alone = x.m_an_element_alone;
    m_a_limited_other_value = x.m_a_limited_other_value;
}

SecondLevelElement::SecondLevelElement(
        SecondLevelElement&& x) noexcept
{
    m_an_element_alone = std::move(x.m_an_element_alone);
    m_a_limited_other_value = std::move(x.m_a_limited_other_value);
}

SecondLevelElement& SecondLevelElement::operator =(
        const SecondLevelElement& x)
{

    m_an_element_alone = x.m_an_element_alone;
    m_a_limited_other_value = x.m_a_limited_other_value;
    return *this;
}

SecondLevelElement& SecondLevelElement::operator =(
        SecondLevelElement&& x) noexcept
{

    m_an_element_alone = std::move(x.m_an_element_alone);
    m_a_limited_other_value = std::move(x.m_a_limited_other_value);
    return *this;
}

bool SecondLevelElement::operator ==(
        const SecondLevelElement& x) const
{
    return (m_an_element_alone == x.m_an_element_alone &&
           m_a_limited_other_value == x.m_a_limited_other_value);
}

bool SecondLevelElement::operator !=(
        const SecondLevelElement& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member an_element_alone
 * @param _an_element_alone New value to be copied in member an_element_alone
 */
void SecondLevelElement::an_element_alone(
        const ThirdLevelElement& _an_element_alone)
{
    m_an_element_alone = _an_element_alone;
}

/*!
 * @brief This function moves the value in member an_element_alone
 * @param _an_element_alone New value to be moved in member an_element_alone
 */
void SecondLevelElement::an_element_alone(
        ThirdLevelElement&& _an_element_alone)
{
    m_an_element_alone = std::move(_an_element_alone);
}

/*!
 * @brief This function returns a constant reference to member an_element_alone
 * @return Constant reference to member an_element_alone
 */
const ThirdLevelElement& SecondLevelElement::an_element_alone() const
{
    return m_an_element_alone;
}

/*!
 * @brief This function returns a reference to member an_element_alone
 * @return Reference to member an_element_alone
 */
ThirdLevelElement& SecondLevelElement::an_element_alone()
{
    return m_an_element_alone;
}


/*!
 * @brief This function copies the value in member a_limited_other_value
 * @param _a_limited_other_value New value to be copied in member a_limited_other_value
 */
void SecondLevelElement::a_limited_other_value(
        const std::vector<ThirdLevelElement>& _a_limited_other_value)
{
    m_a_limited_other_value = _a_limited_other_value;
}

/*!
 * @brief This function moves the value in member a_limited_other_value
 * @param _a_limited_other_value New value to be moved in member a_limited_other_value
 */
void SecondLevelElement::a_limited_other_value(
        std::vector<ThirdLevelElement>&& _a_limited_other_value)
{
    m_a_limited_other_value = std::move(_a_limited_other_value);
}

/*!
 * @brief This function returns a constant reference to member a_limited_other_value
 * @return Constant reference to member a_limited_other_value
 */
const std::vector<ThirdLevelElement>& SecondLevelElement::a_limited_other_value() const
{
    return m_a_limited_other_value;
}

/*!
 * @brief This function returns a reference to member a_limited_other_value
 * @return Reference to member a_limited_other_value
 */
std::vector<ThirdLevelElement>& SecondLevelElement::a_limited_other_value()
{
    return m_a_limited_other_value;
}




FirstLevelElement::FirstLevelElement()
{
    // Just to register all known types
    registercomplex_nested_arraysTypes();
}

FirstLevelElement::~FirstLevelElement()
{
}

FirstLevelElement::FirstLevelElement(
        const FirstLevelElement& x)
{
    m_useless_name = x.m_useless_name;
    m_sub = x.m_sub;
    m_an_element_alone = x.m_an_element_alone;
}

FirstLevelElement::FirstLevelElement(
        FirstLevelElement&& x) noexcept
{
    m_useless_name = std::move(x.m_useless_name);
    m_sub = std::move(x.m_sub);
    m_an_element_alone = std::move(x.m_an_element_alone);
}

FirstLevelElement& FirstLevelElement::operator =(
        const FirstLevelElement& x)
{

    m_useless_name = x.m_useless_name;
    m_sub = x.m_sub;
    m_an_element_alone = x.m_an_element_alone;
    return *this;
}

FirstLevelElement& FirstLevelElement::operator =(
        FirstLevelElement&& x) noexcept
{

    m_useless_name = std::move(x.m_useless_name);
    m_sub = std::move(x.m_sub);
    m_an_element_alone = std::move(x.m_an_element_alone);
    return *this;
}

bool FirstLevelElement::operator ==(
        const FirstLevelElement& x) const
{
    return (m_useless_name == x.m_useless_name &&
           m_sub == x.m_sub &&
           m_an_element_alone == x.m_an_element_alone);
}

bool FirstLevelElement::operator !=(
        const FirstLevelElement& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member useless_name
 * @param _useless_name New value to be copied in member useless_name
 */
void FirstLevelElement::useless_name(
        const std::string& _useless_name)
{
    m_useless_name = _useless_name;
}

/*!
 * @brief This function moves the value in member useless_name
 * @param _useless_name New value to be moved in member useless_name
 */
void FirstLevelElement::useless_name(
        std::string&& _useless_name)
{
    m_useless_name = std::move(_useless_name);
}

/*!
 * @brief This function returns a constant reference to member useless_name
 * @return Constant reference to member useless_name
 */
const std::string& FirstLevelElement::useless_name() const
{
    return m_useless_name;
}

/*!
 * @brief This function returns a reference to member useless_name
 * @return Reference to member useless_name
 */
std::string& FirstLevelElement::useless_name()
{
    return m_useless_name;
}


/*!
 * @brief This function copies the value in member sub
 * @param _sub New value to be copied in member sub
 */
void FirstLevelElement::sub(
        const std::vector<SecondLevelElement>& _sub)
{
    m_sub = _sub;
}

/*!
 * @brief This function moves the value in member sub
 * @param _sub New value to be moved in member sub
 */
void FirstLevelElement::sub(
        std::vector<SecondLevelElement>&& _sub)
{
    m_sub = std::move(_sub);
}

/*!
 * @brief This function returns a constant reference to member sub
 * @return Constant reference to member sub
 */
const std::vector<SecondLevelElement>& FirstLevelElement::sub() const
{
    return m_sub;
}

/*!
 * @brief This function returns a reference to member sub
 * @return Reference to member sub
 */
std::vector<SecondLevelElement>& FirstLevelElement::sub()
{
    return m_sub;
}


/*!
 * @brief This function copies the value in member an_element_alone
 * @param _an_element_alone New value to be copied in member an_element_alone
 */
void FirstLevelElement::an_element_alone(
        const ThirdLevelElement& _an_element_alone)
{
    m_an_element_alone = _an_element_alone;
}

/*!
 * @brief This function moves the value in member an_element_alone
 * @param _an_element_alone New value to be moved in member an_element_alone
 */
void FirstLevelElement::an_element_alone(
        ThirdLevelElement&& _an_element_alone)
{
    m_an_element_alone = std::move(_an_element_alone);
}

/*!
 * @brief This function returns a constant reference to member an_element_alone
 * @return Constant reference to member an_element_alone
 */
const ThirdLevelElement& FirstLevelElement::an_element_alone() const
{
    return m_an_element_alone;
}

/*!
 * @brief This function returns a reference to member an_element_alone
 * @return Reference to member an_element_alone
 */
ThirdLevelElement& FirstLevelElement::an_element_alone()
{
    return m_an_element_alone;
}




complex_nested_arrays::complex_nested_arrays()
{
    // Just to register all known types
    registercomplex_nested_arraysTypes();
}

complex_nested_arrays::~complex_nested_arrays()
{
}

complex_nested_arrays::complex_nested_arrays(
        const complex_nested_arrays& x)
{
    m_array_of_elements = x.m_array_of_elements;
}

complex_nested_arrays::complex_nested_arrays(
        complex_nested_arrays&& x) noexcept
{
    m_array_of_elements = std::move(x.m_array_of_elements);
}

complex_nested_arrays& complex_nested_arrays::operator =(
        const complex_nested_arrays& x)
{

    m_array_of_elements = x.m_array_of_elements;
    return *this;
}

complex_nested_arrays& complex_nested_arrays::operator =(
        complex_nested_arrays&& x) noexcept
{

    m_array_of_elements = std::move(x.m_array_of_elements);
    return *this;
}

bool complex_nested_arrays::operator ==(
        const complex_nested_arrays& x) const
{
    return (m_array_of_elements == x.m_array_of_elements);
}

bool complex_nested_arrays::operator !=(
        const complex_nested_arrays& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member array_of_elements
 * @param _array_of_elements New value to be copied in member array_of_elements
 */
void complex_nested_arrays::array_of_elements(
        const std::array<FirstLevelElement, 3>& _array_of_elements)
{
    m_array_of_elements = _array_of_elements;
}

/*!
 * @brief This function moves the value in member array_of_elements
 * @param _array_of_elements New value to be moved in member array_of_elements
 */
void complex_nested_arrays::array_of_elements(
        std::array<FirstLevelElement, 3>&& _array_of_elements)
{
    m_array_of_elements = std::move(_array_of_elements);
}

/*!
 * @brief This function returns a constant reference to member array_of_elements
 * @return Constant reference to member array_of_elements
 */
const std::array<FirstLevelElement, 3>& complex_nested_arrays::array_of_elements() const
{
    return m_array_of_elements;
}

/*!
 * @brief This function returns a reference to member array_of_elements
 * @return Reference to member array_of_elements
 */
std::array<FirstLevelElement, 3>& complex_nested_arrays::array_of_elements()
{
    return m_array_of_elements;
}


// Include auxiliary functions like for serializing/deserializing.
#include "complex_nested_arraysCdrAux.ipp"

#endif // FASTCDR_VERSION_MAJOR > 1
